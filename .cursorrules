# Interior Inspiration Website Tech Stack and Project Structure

## Project Type
- Static Website (SSG - Static Site Generation)
- Important Notes:
  - All pages are pre-rendered at build time
  - No server-side operations after deployment
  - Content updates require rebuild and redeploy
  - Build output is in /out directory

## Tech Stack
- Framework: Next.js 13.5.8 (App Router)
- Language: TypeScript
- Styling: Tailwind CSS 3.3.6
- Content Management: 
  - MDX (with @mdx-js)
  - Contentlayer
  - next-mdx-remote
- UI Components:
  - @headlessui/react
  - @heroicons/react
  - react-icons
- Image Processing: Cloudinary
- Development Tools:
  - ESLint
  - PostCSS
  - TypeScript
  - ts-node

## MDX 技術選擇歷史與決策過程

### 背景：Next.js 13 早期的 MDX 相容性問題
在 Next.js 13 剛發布時（特別是 App Router 還在 beta 階段），MDX 整合存在重大相容性問題。

### 技術選擇演進過程

#### 1. 第一次嘗試：`@next/mdx`（官方包）
**選擇原因**：官方推薦的 MDX 解決方案
**遇到的問題**：
- 對 Next.js 13 App Router 支援極差，bug 眾多
- 靜態匯出（`output: 'export'`）功能不穩定
- Server Components 整合有嚴重問題
- 需要 `mdx-components.tsx` 但官方文檔不清楚
- 編譯時經常出現莫名錯誤

**結論**：❌ 放棄，因為 bug 太多無法用於生產環境

#### 2. 第二次嘗試：`next-mdx-remote`（社群包）
**選擇原因**：社群包對 Next.js 13 相容性更好
**優點**：
- ✅ 解決了 Next.js 13 App Router 相容性問題
- ✅ 更靈活的內容載入方式
- ✅ 可以從任何來源（API、CMS、檔案系統）載入 MDX

**致命缺點**：
- ❌ **不支援靜態網站生成**（`output: 'export'`）
- ❌ 是**執行時編譯**，需要伺服器環境
- ❌ 無法在純靜態網站中使用

**技術原理**：
```typescript
// next-mdx-remote 的工作方式
const mdxSource = await serialize(content) // 需要 Node.js 執行時環境
<MDXRemote {...mdxSource} />              // 客戶端或伺服器端動態編譯
```

**結論**：❌ 放棄，因為專案需求是靜態網站

#### 3. 最終選擇：`Contentlayer`
**選擇原因**：專為靜態網站和 Next.js 13 設計的解決方案
**完美解決所有問題**：
- ✅ 完全支援 Next.js 13 App Router
- ✅ 完美支援靜態網站生成（`output: 'export'`）
- ✅ **編譯時處理**（不是執行時），適合靜態網站
- ✅ 自動生成 TypeScript 型別定義
- ✅ 優秀的 frontmatter 和內容結構化支援
- ✅ 內建圖片處理和最佳化
- ✅ 效能優異，編譯時預處理所有內容

**技術原理**：
```typescript
// Contentlayer 的工作方式
const post = allPosts.find(p => p.slug === slug)           // 編譯時生成的資料
const MDXContent = getMDXComponent(post.body.code)         // 預編譯的 React 元件程式碼
return <MDXContent components={useMDXComponents({})} />    // 直接渲染，無需執行時編譯
```

### 為什麼 package.json 中還有 next-mdx-remote？
- `next-mdx-remote` 在 `package.json` 中但沒有實際使用
- 這是技術選擇演進過程的遺留，發現它不支援靜態匯出後就改用 Contentlayer
- 保留是為了記錄技術決策過程

### 關鍵技術差異總結

| 特性 | @next/mdx | next-mdx-remote | Contentlayer |
|------|-----------|-----------------|--------------|
| Next.js 13 支援 | ❌ Bug 眾多 | ✅ 良好 | ✅ 完美 |
| 靜態匯出支援 | ❌ 不穩定 | ❌ 不支援 | ✅ 完美支援 |
| 處理時機 | 編譯時 | 執行時 | 編譯時 |
| TypeScript 支援 | 基本 | 基本 | ✅ 自動生成型別 |
| 內容管理 | 基本 | 靈活 | ✅ 結構化管理 |
| 效能 | 好 | 較差 | ✅ 最佳 |

### 最終架構
- **內容來源**：`content/` 目錄下的 MDX 檔案
- **編譯工具**：Contentlayer 在建置時處理所有 MDX
- **型別安全**：自動生成的 TypeScript 型別（`contentlayer/generated`）
- **渲染方式**：`getMDXComponent()` + `useMDXComponents()`
- **自訂元件**：透過 `mdx-components.tsx` 提供自訂 MDX 元件映射

這個技術選擇過程完美體現了「選擇適合專案需求的技術」的重要性。

## Typography
- Font Implementation:
  - Using next/font/local for optimal performance
  - Fonts are locally hosted in /public/fonts/
  - Default font settings are configured in app/layout.tsx body tag
  - Font loading strategy: 'swap' for better performance

## Project Structure
/
├── app/                    # Next.js app router pages and components
├── content/               # MDX content files
├── .contentlayer/         # Generated content layer files
├── public/               # Static assets
├── scripts/              # Utility scripts (image processing etc.)
├── types/                # TypeScript type definitions
└── components/           # Reusable React components

## Configuration Files
- next.config.js          # Next.js configuration
- contentlayer.config.ts  # Content layer configuration
- tailwind.config.ts     # Tailwind CSS configuration
- tsconfig.json          # TypeScript configuration
- postcss.config.js      # PostCSS configuration
- eslint.config.mjs      # ESLint configuration

## Build and Development
- Development: `npm run dev`
- Production Build: `npm run build` (Generates static files in /out)
- Preview: `npm run preview` (Serves static files from /out)
- Content Tools: 
  - Image Upload: `npm run upload-images`
  - Image Upload Test: `npm run upload-images:test`
  - Generate Image Sitemap: `npm run generate-image-sitemap`

## Node.js 腳本運行環境詳解

### 背景：原始圖片處理系統
你原本建立這個 Node.js 環境是為了運行圖片批量上傳到 Cloudinary 的腳本：
- `npm run upload-images` - 批量上傳所有圖片
- `npm run upload-images:test` - 測試單一文章的圖片上傳

### 1. 為什麼需要特殊的 Node.js 設定？

**問題**：你的圖片處理腳本是用 TypeScript 寫的（`.mts` 檔案），但 Node.js 原生不支援直接執行 TypeScript。

**解決方案**：建立一個特殊的執行環境，讓 Node.js 可以直接運行 TypeScript 檔案。

### 2. 設定檔案解析

#### `scripts/package.json`
```json
{
  "type": "module",
  "private": true
}
```
- **作用**：告訴 Node.js 這個目錄下的所有 `.js` 檔案都是 ES Module 格式
- **為什麼需要**：現代 JavaScript 語法，支援 `import/export`

#### `scripts/register.mjs`
```javascript
import { register } from 'node:module';
import { pathToFileURL } from 'node:url';

register('ts-node/esm', pathToFileURL('./'));
```
- **作用**：這是一個「載入器註冊器」
- **功能**：告訴 Node.js 如何處理 TypeScript 檔案
- **結果**：Node.js 現在可以直接執行 `.ts` 和 `.mts` 檔案

### 3. 執行命令解析

#### 原始圖片上傳命令
```bash
node --import ./scripts/register.mjs scripts/image-processor/index.mts
```

#### 新的 sitemap 生成命令
```bash
node --import ./scripts/register.mjs scripts/generate-image-sitemap.js
```

**執行流程**：
1. `node` 啟動
2. `--import ./scripts/register.mjs` 載入 TypeScript 支援
3. 執行主腳本（可以是 `.mts` 或 `.js`）

### 4. 圖片處理腳本架構

你的原始 `scripts/image-processor/` 包含：
- `index.mts` - 主要執行檔案
- `cloudinaryUploader.mts` - Cloudinary 上傳邏輯
- `imageCollector.mts` - MDX 圖片解析器
- `pinterestPublisher.mts` - Pinterest 發布功能

### 5. 新腳本如何重用現有基礎設施

新的 `generate-image-sitemap.js` 腳本：
- **重用相同的執行環境**：使用同樣的 `register.mjs` 載入器
- **重用現有模組**：動態導入 `imageCollector.mts` 來解析 MDX 圖片
- **重用圖片工具**：導入 `app/utils/imageUtils.ts` 來生成 URL

### 6. 動態導入的必要性

```javascript
// 為什麼不能直接 import？
// import { getCollectedImages } from './image-processor/imageCollector.mts'; // ❌ 會有路徑問題

// 為什麼要用動態導入？
async function importImageCollector() {
  const { getCollectedImages } = await import('./image-processor/imageCollector.mts'); // ✅ 運行時解析
  return { getCollectedImages };
}
```

### 7. 實際運作流程

當你執行 `npm run generate-image-sitemap` 時：

1. **Node.js 啟動** + 載入 TypeScript 支援
2. **執行 sitemap 腳本**
3. **動態導入圖片解析器**（重用你的原始工具）
4. **動態導入圖片 URL 工具**（重用 app 目錄的工具）
5. **讀取 Contentlayer 資料**（避免語法衝突）
6. **生成 sitemap XML**

### 8. 為什麼這樣設計？

- **重用現有投資**：不需要重寫圖片處理邏輯
- **保持一致性**：使用相同的 Cloudinary 設定和 URL 格式
- **避免重複**：一套 TypeScript 執行環境服務多個腳本
- **模組化設計**：每個腳本專注自己的功能，但可以共享工具

### 9. 簡單總結

你原本為了上傳圖片到 Cloudinary 建立了一個「Node.js 可以執行 TypeScript」的環境。現在新的 sitemap 生成腳本就像是一個新房客，搬進了同一個已經裝修好的房子，重用了相同的基礎設施和工具。 